#!/usr/bin/python3

import re
import subprocess
import logging
import time
import os
import sys
import ctypes
import argparse
import bisect

GET_STORAGE_DETAILS_CMD = '/usr/bin/m0_filesystem_stats'
LIBMERO_PATH = "/usr/lib64/libmero.so"
TOTAL_SPACE = "totalspace"
FREE_SPACE = "freespace"
USAGE_PERCENTAGE = "usedprct"
AVAILABLE = "available"
USED = "used"
SIZE = "size"
#refer mero/iem.h for below parameter values
M0_MERO_IEM_EVENT_FREE_SPACE = 2
M0_MERO_IEM_MODULE_OS = 2
M0_MERO_IEM_SEVERITY_A_ALERT = 1

with open("/etc/sysconfig/mero-free-space-monitor") as f:
    for config in f.read().splitlines():
        if "MERO_FREESPACE_TRIGGER_IEM_FREQ" in config:
            iem_alert_check_interval = int(config.split("=")[-1])
        if "MERO_FREESPACE_TRIGGER_IEM_THRESHOLD" in config:
            iem_threshold_param = config.split("=")[-1]

log = logging.getLogger('IEM AlertLogs')
log.setLevel(logging.ERROR)


def execute_command(command):
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()
    except Exception as e:
        log.error(f"Error in command execution '{command}':{e}")
    if not stdout:
        log.error(f"Failed to process command '{command}':{stderr}")
    log.debug(f"{command} command output stdout:{stdout}")
    return re.sub(' +', ' ', stdout.decode('utf-8')).split('\n')


def read_cluster_size():
    get_storage_details_process = execute_command(GET_STORAGE_DETAILS_CMD)

    cropped_console_data = [str(each_element).strip() for each_element in
                            get_storage_details_process
                            if "space" in each_element]

    capacity_info = {data.split()[0]+data.split()[1]: int(data.split()[2])
                     for data in cropped_console_data}
    storage_detail = {}
    storage_detail[SIZE] = capacity_info[TOTAL_SPACE]
    storage_detail[USED] = (capacity_info[TOTAL_SPACE] -
                            capacity_info[FREE_SPACE])
    storage_detail[AVAILABLE] = capacity_info[FREE_SPACE]
    storage_detail[USAGE_PERCENTAGE] = round(100 - (capacity_info[FREE_SPACE] / capacity_info[TOTAL_SPACE]) * 100, 2)
    return storage_detail

def print_iem(usage_percentage):
        file_parm = os.path.basename(__file__)
        file_parm_b = file_parm.encode('utf-8')
        function_parm = sys._getframe().f_code.co_filename
        line_num = sys._getframe().f_lineno
        sev_id = M0_MERO_IEM_SEVERITY_A_ALERT
        mod_id = M0_MERO_IEM_MODULE_OS
        evt_id = M0_MERO_IEM_EVENT_FREE_SPACE
        msg = f"Cluster size: {usage_percentage}"
        msg_b = msg.encode('utf-8')
        libmero.m0_mero_iem(ctypes.c_char_p(file_parm_b), function_parm, line_num, sev_id,
                            mod_id, evt_id, ctypes.c_char_p(msg_b))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = "mero free space monitor")
    parser.add_argument("-S", "--singlenode", help = "Single node", required = False, default = "")
    parser.add_argument("-l", "--libmero", help = "library path", required = False, default = "")
    argument = parser.parse_args()
    if argument.libmero:
        LIBMERO_PATH = argument.libmero
        GET_STORAGE_DETAILS_CMD = GET_STORAGE_DETAILS_CMD + ' -l ' +  argument.libmero
    if argument.singlenode:
        GET_STORAGE_DETAILS_CMD = GET_STORAGE_DETAILS_CMD + ' ' +  argument.singlenode

    param_list = [int(x) for x in iem_threshold_param.split()]
    param_list.sort()  # bisect.bisect_right() will expect it sorted
    thr_min = min(param_list)
    thr_max = max(param_list)
    iem_alert_low_thresold = thr_min
    iem_alert_high_thresold = thr_max
    iem_min_threshold = iem_alert_low_thresold
    list_len = len(param_list)

    libmero = ctypes.CDLL(LIBMERO_PATH)
    cluster_usage_prev = 0
    while True:
        send_iem = False
        wait_time = iem_alert_check_interval
        cluster_size = read_cluster_size()
        cluster_usage_percentage = cluster_size[USAGE_PERCENTAGE]
        if cluster_usage_percentage > iem_min_threshold:
            if (cluster_usage_prev < iem_alert_low_thresold and
                cluster_usage_percentage > iem_alert_low_thresold):
                send_iem = True
            if (cluster_usage_prev < iem_alert_high_thresold and
                cluster_usage_percentage > iem_alert_high_thresold):
                send_iem = True

            if send_iem == True:
                idx = bisect.bisect_right(param_list, int(iem_alert_low_thresold))
                if idx >= list_len:
                    idx = list_len - 1
                iem_alert_low_new = param_list[idx]
                if iem_alert_high_thresold > iem_alert_low_thresold:
                    iem_alert_low_thresold = iem_alert_low_new
                    print_iem(cluster_usage_percentage)
            cluster_usage_prev = cluster_usage_percentage
        else:
            if cluster_usage_prev > iem_min_threshold:
                print_iem(cluster_usage_percentage)
                cluster_usage_prev = 0
                iem_alert_low_thresold = thr_min
                iem_alert_high_thresold = thr_max
        time.sleep(wait_time)
